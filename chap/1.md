## 1. ファイルディスクリプタと移植性

　Ruby C APIにはファイル操作関係ももちろんある。C言語プログラミングするためにstdioのFILE型へのポインタを渡すのにrb_io_stdio_file() API関数が用意されている。  
　宣言は以下:  

```
FILE *rb_io_stdio_file(rb_io_t *fptr);
```
　利用するには`<ruby/io.h>`をインクルードする必要がある。大概、APIは`<ruby.h>`で読み込めば関連するヘッダファイルをいっぺんに読み込むが、`<ruby/io.h>`はその対象から除外されていて、開発者が自前で読み込むという仕組みがなされているようだ。
  
　ただし、C言語は高水準言語だがオーソドックスだからこそのデメリットもある。ミューテックスなどを標準実装したり、C言語では読み込めるファイルのサイズに制限がある(2GBの壁など)を解消するべくI/O関連のシステムコールはミックスされるので、素でstdioのライブラリを使用するのは危険である。  
　当然、このAPIの説明でも注意喚起がなされている。  

> @note  Note however, that `FILE`s can have their own buffer. Mixing Ruby's and stdio's file are basically dangerous. Use with care.

> (約) 注意: ただ、`FILE`型は独自にバッファを持ち合わせていることに注意してください。ミックスされたRubyの、そのstdioのファイル操作ライブラリは基本的に危険です。注意してご利用ください。

　fread()のような動作を必要とするなら、rb_funcall() API関数を使い `#readpartial`をインターンするのが無難だろうし、ソースコードの`io.c`にもそう書いてある。  

　とはいえ、Cで書かれたソフトウェアは、ほとんどstdioがミックスされるため、実装によってはシステムコールがスコープ隠蔽されているなんてことある。この場合、C++でいうコンストラクタに`FILE`型を“組み込む”ようにあるので、独自実装に取り込むのはそう簡単ではない。  
　もっとも、開発者が悲鳴を上げるソフトウェアのAPI実装例は、例外制御を独自に実装しているというものだ。例外が発生したのなら、強制的にabort()で終了するので、これはいけない。「このソフトウェアを使うくらいなら自前で用意するぞ」となるわけである。  
　したがって、多くの開発者にとって、変数のイニシャライザにアロケータなどのシステムコールをスコープ隠蔽するのは、なんとも泣かせどころである。典型例は以下のようなAPIだろうか。  

```CXX
// ソフトウェアの実体hoge_tにstdioをフックするAPI
void hoge_hook_stdio(FILE *fp, hoge_t *obj);
```

　ベイズ推定のような「四角サイコロの目の数は全部で6に決まっている」というアイディアは、否定観念さえ判断材料とする。ここで開発者がAPIを利用するのに、「システムコールの扱い方はこうに決まっている」というアイディアがあるものの、APIの開発者と利用者との間にアイディアの相違があって、それが半ば矛盾に差し掛かる。
これは興味深い。  
　Rubyの拡張ライブラリで外部ソフトウェアを利用する場合、ファイルのやり取りではCの`FILE`型を利用することも、あながち少ないわけでもない。前例を当てはめてみると、「使い道が限られる」のがわかる。  

　C言語プログラミングではstdioは標準ライブラリでも主流で、利用される割合は高い。とはいえ、開発したデニス・リッチー博士とブライアン・カーニハン博士は「stdioはC言語の一部ではない」と明言している。  
　実は、`FILE`型へのポインタを渡すAPI関数はもう1つある。それがrb_fdopen()である。これはファイルディスクリプタを使ってポインタを取得する。  
　宣言は以下。  

```CXX
FILE *rb_fdopen(int fd, const char *modestr);
```

　UNIXのシステムコールとして昔からあるfdopen()を模したもので、第一引数にはファイル・ディスクリプタの番号を、第二引数にはオープナーのモードを文字列で指定する。(例によって、バイナリ読み込みなら"rb"、テキスト書き込みなら"w"など)  
　ここで、多くのプログラマは、利用にこう難儀を持つだろう。「移植性はどうする？非UNIX標準OSを考えると、利用は控えたいところだ」と。こうした疑問に感じる広義について、Ruby C APIの説明では、しっかり書かれており、折にどう使えばいいかヒントまで書いてある。注意して読むべきだろう。  

　以下は説明文。  

> Identical to rb_io_stdio_file(), except it takes file descriptors instead of Ruby's IO.  
> It can also be seen as a compatibility layer to wrap `fdopen(3)`.  
> Nowadays all supporting systems, including Windows, have `fdopen`. Why not use them.  

> (約)  
> rb_io_stdio_file() と同じですが、RubyのIOの代わりにファイルディスクリプタを使用します。  
> これは fdopen(3) をラップする互換性レイヤーとも見なすことができます。  
> 今日では、Windows を含むすべてのサポートシステムには 'fdopen' があります。こちらを使ってみては？  

　説明にはrb_io_stdio_file() API関数と比較して、「WindowsはUNIXライクなOSではないのでファイルディスクリプタには対応していないと思いがちだが、Windowsも対応しているというなら話は別だ、移植性も問題がない」という暗示がある。  

　ここで利用を考えよう。RubyのIOオブジェクトからファイル・ディスクリプタ番号を取り出すAPI関数を組み合わせると、例えばバイナリ読み込みなら、以下のようなコードになる。  

```CXX
FILE *fp = rb_fdopen(rb_io_discriptor(io), "rb");
```
　変数にせず、直接APIの引数にファイルポインタを渡すコーディングもある。ただ、個人的に言わせれば、いじめに感じる;

```CXX
hoge_hook_stdio(rb_fdopen(rb_io_descriptor(io), "rb"), &obj);
```
